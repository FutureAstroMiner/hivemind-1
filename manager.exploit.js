var utilities = require('utilities');

var Exploit = function (room, flagName) {
    var flag = Game.flags[flagName];
    var roomName = flag.pos.roomName;
    this.units = {};
    this.name = roomName;
    this.roomName = roomName;
    this.flag = flag;

    this.sourceRoom = room;

    // Prepare memory
    if (!Memory.exploits) {
        Memory.exploits = {};
    }
    if (!Memory.exploits[roomName]) {
        Memory.exploits[roomName] = {};
    }

    this.memory = Memory.exploits[roomName];

    // Adjust flag color.
    if (flag.color != COLOR_RED) {
        flag.setColor(COLOR_RED);
    }

    // Collect creeps from temp data.
    if (Game.exploitTemp && Game.exploitTemp[this.name]) {
        for (let i in Game.exploitTemp[this.name]) {
            let creep = Game.getObjectById(Game.exploitTemp[this.name][i]);

            if (!this.units[creep.memory.exploitUnitType]) {
                this.units[creep.memory.exploitUnitType] = [];
            }
            this.units[creep.memory.exploitUnitType].push(creep);
        }
    }

    this.calculatePaths();
};

Exploit.prototype.calculatePaths = function () {
    // Calculate path into room.
    if (!this.memory.pathToRoom || !this.memory.pathToRoomCalculated || this.memory.pathToRoomCalculated < Game.time - 10000) {
        var startPosition = this.sourceRoom.getStorageLocation();
        startPosition = new RoomPosition(startPosition.x, startPosition.y, this.sourceRoom.name);
        if (this.sourceRoom.storage) {
            startPosition = this.sourceRoom.storage.pos;
        }

        var endPosition = new RoomPosition(25, 25, flag.pos.roomName);

        var result = utilities.getPath(startPosition, {pos: endPosition, range: 20});

        if (result) {
            //console.log('found path in', result.ops, 'operations', result.path);

            this.memory.pathToRoom = Room.serializePositionPath(result.path);
            this.memory.pathToRoomCalculated = Game.time;
        }
        else {
            console.log('No path found!');
        }
        return;
    }

    // Calculate paths between source keepers.
};

Exploit.prototype.addSpawnOptions = function (options) {
    if (_.size(this.units.guardian) < 1) {
        // @todo Only spawn guardian if room is protected by source keepers.
        options.push({
            role: 'exploit',
            priority: 3,
            weight: 1,
            subRole: 'guardian',
            exploit: this.name,
        });
    }
};

Exploit.prototype.spawnUnit = function (spawn, option) {
    if (option.subRole == 'guardian') {
        spawn.createManagedCreep({
            role: 'brawler',
            body: [
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
                MOVE, MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK,
                ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK,
                ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, HEAL, HEAL, HEAL, HEAL, HEAL
            ],
            memory: {
                exploitName: this.name,
                exploitUnitType: 'guardian',
            },
        });
    }

    return true;
};

module.exports = Exploit;
