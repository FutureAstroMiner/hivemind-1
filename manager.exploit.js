var utilities = require('utilities');

var Exploit = function (room, flagName) {
    var flag = Game.flags[flagName];
    var roomName = flag.pos.roomName;
    this.units = {};
    this.name = roomName;
    this.roomName = roomName;
    this.flag = flag;

    this.sourceRoom = room;

    // Prepare memory
    if (!Memory.exploits) {
        Memory.exploits = {};
    }
    if (!Memory.exploits[roomName]) {
        Memory.exploits[roomName] = {};
    }

    this.memory = Memory.exploits[roomName];

    // Adjust flag color.
    if (flag.color != COLOR_RED) {
        flag.setColor(COLOR_RED);
    }

    // Collect creeps from temp data.
    if (Game.exploitTemp && Game.exploitTemp[this.name]) {
        for (let i in Game.exploitTemp[this.name]) {
            let creep = Game.getObjectById(Game.exploitTemp[this.name][i]);

            if (!this.units[creep.memory.exploitUnitType]) {
                this.units[creep.memory.exploitUnitType] = [];
            }
            this.units[creep.memory.exploitUnitType].push(creep);
        }
    }

    // Collect source keeper lair positions.
    if (!this.memory.lairs && Memory.rooms[this.roomName] && Memory.rooms[this.roomName].intel) {
        let intel = Memory.rooms[this.roomName].intel;
        let lairs = intel.structures[STRUCTURE_KEEPER_LAIR];
        if (lairs) {
            this.memory.lairs = {};
            for (let id in lairs) {
                this.memory.lairs[id] = {
                    paths: {},
                };

                // @todo Also save associated resources.
            }
        }
    }

    // Cache paths around the room.
    this.calculatePaths();

    // Save closest lair to entrance point.
    if (this.memory.lairs && this.memory.pathToRoom && !this.memory.closestLairToEntrance) {
        let lastPos = utilities.decodePosition(this.memory.pathToRoom[this.memory.pathToRoom.length - 1]);
        let bestRange = null;
        let best = null;
        for (let id in this.memory.lairs) {
            let lair = Game.getObjectById(id);
            if (lair && (!best || lastPos.getRangeTo(lair) < bestRange)) {
                best = id;
                bestRange = lastPos.getRangeTo(lair);
            }
        }

        if (best) {
            this.memory.closestLairToEntrance = best;
        }
    }

    // Try and build roads where needed.
    this.buildRoads();
};

Exploit.prototype.buildRoads = function () {
    if (!this.memory.lastRoadCheck || this.memory.lastRoadCheck < Game.time - 123 && _.size(Game.constructionSizes) < 75) {
        if (Game.rooms[this.roomName] && this.memory.lairs) {
            let room = Game.rooms[this.roomName];
            let sites = room.find(FIND_CONSTRUCTION_SITES);
            let numSites = sites.length;
            this.memory.lastRoadCheck = Game.time;

            for (id in this.memory.lairs) {
                for (id2 in this.memory.lairs) {
                    if (this.memory.lairs[id].paths[id2] && this.memory.lairs[id].paths[id2].path) {
                        let path = this.memory.lairs[id].paths[id2].path;
                        for (let i in path) {
                            if (numSites >= 10) return;
                            let pos = utilities.decodePosition(path[i]);

                            let structures = pos.lookFor(LOOK_STRUCTURES);
                            let sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

                            if (structures.length > 0 || sites.length > 0) continue;
                            if (pos.createConstructionSite(STRUCTURE_ROAD) == OK) {
                                numSites++;
                            }
                        }
                    }
                }
            }
        }
    }
};

Exploit.prototype.calculatePaths = function () {
    // Calculate path into room.
    if (!this.memory.pathToRoom || !this.memory.pathToRoomCalculated || this.memory.pathToRoomCalculated < Game.time - 10000) {
        var startPosition = this.sourceRoom.getStorageLocation();
        startPosition = new RoomPosition(startPosition.x, startPosition.y, this.sourceRoom.name);
        if (this.sourceRoom.storage) {
            startPosition = this.sourceRoom.storage.pos;
        }

        var endPosition = new RoomPosition(25, 25, flag.pos.roomName);

        var result = utilities.getPath(startPosition, {pos: endPosition, range: 20});

        if (result) {
            //console.log('found path in', result.ops, 'operations', result.path);

            this.memory.pathToRoom = Room.serializePositionPath(result.path);
            this.memory.pathToRoomCalculated = Game.time;
            delete this.memory.closestLairToEntrance;
        }
        else {
            console.log('No path found!');
        }
        return;
    }

    // Calculate paths between source keeper lairs.
    for (let id in this.memory.lairs) {
        for (let id2 in this.memory.lairs) {
            if (id == id2) continue;
            if (this.memory.lairs[id].paths[id2]) continue;

            var lair = Game.getObjectById(id);
            var lair2 = Game.getObjectById(id2);

            if (!lair || !lair2) continue;

            var result = utilities.getPath(lair.pos, {pos: lair2.pos, range: 1});

            if (result) {
                this.memory.lairs[id].paths[id2] = {
                    path: Room.serializePositionPath(result.path),
                    lastCalculated: Game.time,
                };
                this.memory.lairs[id2].paths[id] = {
                    reverse: true,
                    lastCalculated: Game.time,
                };
            }
            else {
                console.log('No path found!');
            }
            return;
        }
    }
};

Exploit.prototype.addSpawnOptions = function (options) {
    if (_.size(this.units.guardian) < 1) {
        // @todo Only spawn guardian if room is protected by source keepers.
        options.push({
            role: 'exploit',
            priority: 3,
            weight: 1,
            subRole: 'guardian',
            exploit: this.name,
        });
    }
};

Exploit.prototype.spawnUnit = function (spawn, option) {
    if (option.subRole == 'guardian') {
        spawn.createManagedCreep({
            role: 'brawler',
            body: [
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
                MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK,
                ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK,
                ATTACK, ATTACK, ATTACK, ATTACK, MOVE, HEAL, HEAL, HEAL, HEAL, HEAL
            ],
            memory: {
                exploitName: this.name,
                exploitUnitType: 'guardian',
            },
        });
    }

    return true;
};

module.exports = Exploit;
