'use strict';

/* global Creep FIND_DROPPED_RESOURCES RESOURCE_ENERGY FIND_SOURCES_ACTIVE
FIND_STRUCTURES FIND_MY_CONSTRUCTION_SITES */

const utilities = require('./utilities');

/**
 * Gathers energy while on an exploit operation.
 */
Creep.prototype.performGetExploitEnergy = function () {
	// Find nearby energy on the ground.
	if (!this.memory.energyTarget) {
		const energy = this.pos.findInRange(FIND_DROPPED_RESOURCES, 3, {
			filter: energy => energy.amount > this.carryCapacity * 0.3 && energy.resourceType === RESOURCE_ENERGY,
		});
		if (energy.length > 0) {
			// Cache target energy to avoid ping-pong between it and target source.
			this.memory.energyTarget = energy[0].id;
		}
	}

	if (this.memory.energyTarget) {
		const energy = Game.getObjectById(this.memory.energyTarget);
		if (energy) {
			if (this.pos.getRangeTo(energy) > 1) {
				this.moveToRange(energy, 1);
			}
			else {
				this.pickup(energy);
			}

			return;
		}

		delete this.memory.energyTarget;
	}

	// Harvest from safe sources.
	const source = this.pos.findClosestByRange(FIND_SOURCES_ACTIVE, {
		filter: source => !source.isDangerous(),
	});

	if (!source) return;

	const container = source.getNearbyContainer();
	if (container && container.store.energy > this.carryCapacity * 0.5) {
		if (this.pos.getRangeTo(container) > 1) {
			this.moveToRange(container, 1);
		}
		else {
			this.withdraw(container, RESOURCE_ENERGY);
		}

		return;
	}

	if (this.pos.getRangeTo(source) > 1) {
		this.moveToRange(source, 1);
	}
	else {
		this.harvest(source);
	}
};

/**
 * Makes the creep use energy to finish construction sites in the current room.
 */
Creep.prototype.performExploitBuild = function () {
	// Repair structures around the room when necessary.
	if (!this.memory.repairTarget && Game.time % 10 === 0) {
		const structure = this.pos.findClosestByRange(FIND_STRUCTURES, {
			filter: structure => structure.hits && structure.hits < structure.hitsMax * 0.5,
		});

		if (structure) {
			this.memory.repairTarget = structure.id;
			delete this.memory.buildTarget;
		}
	}

	if (this.memory.repairTarget) {
		const target = Game.getObjectById(this.memory.repairTarget);
		if (target) {
			if (target.hits >= target.hitsMax) {
				delete this.memory.repairTarget;
			}
			else if (this.pos.getRangeTo(target) > 3) {
				this.moveToRange(target, 3);
				if (Game.cpu.bucket > 5000) {
					this.repairNearby();
				}
			}
			else {
				this.repair(target);
			}

			return;
		}

		delete this.memory.repairTarget;
	}

	// Build stuff in the room.
	if (!this.memory.buildTarget) {
		const targets = this.room.find(FIND_MY_CONSTRUCTION_SITES);
		if (targets.length <= 0) {
			return;
		}

		this.memory.buildTarget = utilities.getClosest(this, targets);
	}

	const best = this.memory.buildTarget;
	if (!best) {
		return;
	}

	const target = Game.getObjectById(best);
	if (!target) {
		this.memory.buildTarget = null;
		return;
	}

	if (this.pos.getRangeTo(target) > 3) {
		this.moveToRange(target, 3);
		if (Game.cpu.bucket > 5000) {
			this.repairNearby();
		}
	}
	else {
		this.build(target);
	}
};

/**
 * Puts this creep into or out of build mode.
 *
 * @param {boolean} building
 *   Whether to start building or not.
 */
Creep.prototype.setExploitBuilderState = function (building) {
	this.memory.building = building;
	delete this.memory.buildTarget;
	delete this.memory.resourceTarget;
};

/**
 * Makes a creep behave like an exploit builder.
 */
Creep.prototype.runExploitBuilderLogic = function () {
	if (this.memory.building && this.carry.energy === 0) {
		this.setExploitBuilderState(false);
	}
	else if (!this.memory.building && this.carry.energy === this.carryCapacity) {
		this.setExploitBuilderState(true);
	}

	const exploit = Game.exploits[this.memory.exploitName];
	if (exploit) {
		// Follow cached path when requested.
		if (this.hasCachedPath()) {
			this.followCachedPath();
			if (this.hasArrived()) {
				this.clearCachedPath();
			}
			else {
				return;
			}
		}
		else if (this.pos.roomName !== exploit.roomName && exploit.memory.pathToRoom) {
			this.setCachedPath(exploit.memory.pathToRoom, false, 3);
			return;
		}
	}

	if (this.memory.building) {
		this.performExploitBuild();
		return;
	}

	this.performGetExploitEnergy();
};
