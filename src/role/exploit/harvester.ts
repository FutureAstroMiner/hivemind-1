/* global RoomPosition FIND_DROPPED_RESOURCES RESOURCE_ENERGY
FIND_CONSTRUCTION_SITES STRUCTURE_CONTAINER */

import Role from 'role/role';
import {getResourcesIn} from 'utils/store';

declare global {
	interface ExploitHarvesterCreep extends Creep {
		memory: ExploitHarvesterCreepMemory;
		heapMemory: ExploitHarvesterCreepHeapMemory;
	}

	interface ExploitHarvesterCreepMemory extends CreepMemory {
		role: 'harvester.exploit';
		harvesting?: boolean;
		exploitName: string;
		travellingToRoom?: boolean;
		fixedSource: Id<Source>;
	}

	interface ExploitHarvesterCreepHeapMemory extends CreepHeapMemory {
	}
}

export default class ExploitHarvesterRole extends Role {
	constructor() {
		super();

		// Harvesting energy is essential and doesn't need tons of CPU.
		this.stopAt = 0;
		this.throttleAt = 5000;
	}

	/**
	 * Makes a creep behave like an exploit harvester.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 */
	run(creep: ExploitHarvesterCreep) {
		if (!creep.memory.harvesting && creep.store.getUsedCapacity() === 0) {
			this.setHarvesterState(creep, true);
		}
		else if (creep.memory.harvesting && creep.store.getFreeCapacity() === 0) {
			this.setHarvesterState(creep, false);
		}

		if (this.travelToExploitRoom(creep)) return;

		if (this.repairNearbyExploitContainer(creep)) return;

		if (creep.memory.harvesting) {
			this.performExploitHarvest(creep);
			return;
		}

		this.performExploitHarvesterDeliver(creep);
	}

	/**
	 * Puts a creep into or out of harvesting mode.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 * @param {boolean} harvesting
	 *   Whether or not this creep should be harvesting.
	 */
	setHarvesterState(creep: ExploitHarvesterCreep, harvesting: boolean) {
		creep.memory.harvesting = harvesting;
	}

	/**
	 * Moves a creep to its exploit destination.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 *
	 * @return {boolean}
	 *   Whether or not the creep is still busy traveling.
	 */
	travelToExploitRoom(creep: ExploitHarvesterCreep) {
		const exploit = Game.exploits[creep.memory.exploitName];
		if (!exploit) return false;

		// Follow cached path when requested.
		if (!creep.hasCachedPath() && creep.pos.roomName !== exploit.roomName && exploit.memory.pathToRoom) {
			creep.setCachedPath(exploit.memory.pathToRoom, false, 3);
			creep.memory.travellingToRoom = true;
			return true;
		}

		creep.followCachedPath();
		if (!creep.hasArrived()) return true;

		creep.clearCachedPath();
		if (!creep.memory.travellingToRoom) return false;

		// Next, travel to destined source.
		const closest = exploit.memory.closestLairToEntrance;
		const source = Game.getObjectById<Source>(creep.memory.fixedSource);
		if (closest && source && exploit.memory.lairs[closest]) {
			const lair = source.getNearbyLair();
			if (lair) {
				const target = lair.id;
				const path = exploit.memory.lairs[closest].paths[target];
				if (path && path.path) {
					creep.setCachedPath(exploit.memory.lairs[closest].paths[target].path, false, 3);
				}
				else if (path) {
					creep.setCachedPath(exploit.memory.lairs[target].paths[closest].path, true, 3);
				}
			}
		}

		delete creep.memory.travellingToRoom;

		return false;
	}

	/**
	 * Makes sure to keep nearby container repaired.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 *
	 * @return {boolean}
	 *   Whether an action has been performed or not.
	 */
	repairNearbyExploitContainer(creep: ExploitHarvesterCreep) {
		const source = Game.getObjectById<Source>(creep.memory.fixedSource);
		const container = source.getNearbyContainer();

		if (creep.store[RESOURCE_ENERGY] > 0) {
			if (!container) {
				// If a construction site for a container is nearby, help build it to recover.
				const sites = creep.pos.findInRange(FIND_CONSTRUCTION_SITES, 3, {
					filter: site => site.structureType === STRUCTURE_CONTAINER,
				});
				if (sites.length > 0 && creep.store[RESOURCE_ENERGY] >= (creep.getActiveBodyparts(WORK) || 0) * 5) {
					creep.build(sites[0]);
					return true;
				}
			}
			else if (container.hits < container.hitsMax * 0.2 && !source.isDangerous() && creep.store[RESOURCE_ENERGY] >= (creep.getActiveBodyparts(WORK) || 0)) {
				if (creep.pos.getRangeTo(container) > 3) {
					creep.moveTo(container);
				}
				else {
					creep.repair(container);
				}

				return true;
			}
		}

		return false;
	}

	/**
	 * Makes the creep gather resources in the current room.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 */
	performExploitHarvest(creep: ExploitHarvesterCreep) {
		const source = Game.getObjectById<Source>(creep.memory.fixedSource);
		const container = source.getNearbyContainer();

		if (source.isDangerous()) {
			const safeSpot = new RoomPosition(25, 25, creep.room.name);
			if (creep.pos.getRangeTo(safeSpot) > 5) {
				creep.moveToRange(safeSpot, 5);
			}

			return;
		}

		if (!container || container.store.getFreeCapacity() > 0) {
			// Pick up nearby resources and put in container.
			const dropped = creep.pos.findInRange(FIND_DROPPED_RESOURCES, 5, {
				filter: resources => container || resources.resourceType === RESOURCE_ENERGY,
			});
			if (dropped.length > 0) {
				if (creep.pos.getRangeTo(dropped[0]) > 1) {
					creep.moveToRange(dropped[0], 1);
				}
				else {
					creep.pickup(dropped[0]);
				}

				return;
			}
		}

		if (creep.pos.getRangeTo(source) > 1) {
			creep.moveTo(source);
		}
		else {
			creep.harvest(source);
		}

		// If there's a container nearby, directly deposit energy.
		if (creep.store.getUsedCapacity() > creep.store.getCapacity() * 0.5 && container && creep.pos.getRangeTo(container) <= 1) {
			for (const resourceType of getResourcesIn(creep.store)) {
				if (creep.store[resourceType] <= 0) continue;
				creep.transfer(container, resourceType);
				break;
			}
		}
	}

	/**
	 * Dumps minerals a harvester creep has gathered.
	 *
	 * @param {Creep} creep
	 *   The creep to run logic for.
	 */
	performExploitHarvesterDeliver(creep: ExploitHarvesterCreep) {
		const source = Game.getObjectById<Source | Mineral>(creep.memory.fixedSource);
		const container = source.getNearbyContainer();

		// By default, deliver to nearby container if there's space.
		// @todo Deliver anything, not just what the source provides.
		if (container && container.store.getFreeCapacity() > 0) {
			if (creep.pos.getRangeTo(container) > 1) {
				creep.moveTo(container);
			}
			else {
				for (const resourceType of getResourcesIn(creep.store)) {
					if (creep.store[resourceType] <= 0) continue;
					creep.transfer(container, resourceType);
					break;
				}
			}
		}
		else {
			// Just drop it. Somebody will pick it up. Maybe.
			creep.drop(source instanceof Mineral ? source.mineralType : RESOURCE_ENERGY);
		}
	}
}
