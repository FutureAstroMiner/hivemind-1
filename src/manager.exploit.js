'use strict';

/* global RoomPosition COLOR_RED STRUCTURE_KEEPER_LAIR FIND_SOURCES FIND_MINERALS
RESOURCE_ENERGY FIND_CONSTRUCTION_SITES LOOK_STRUCTURES LOOK_CONSTRUCTION_SITES
STRUCTURE_ROAD OK MOVE ATTACK HEAL STRUCTURE_CONTAINER */

const utilities = require('./utilities');

/**
 * Manages an exploit operation for source keeper rooms.
 * @constructor
 *
 * @param {Room} room
 *   The room that will spawn our creeps and reap the spoils of this operation.
 * @param {string} flagName
 *   Name of the flag pointing to the target source keeper room.
 */
const Exploit = function (room, flagName) {
	const flag = Game.flags[flagName];
	const roomName = flag.pos.roomName;
	this.units = {};
	this.name = roomName;
	this.roomName = roomName;
	this.flag = flag;

	this.sourceRoom = room;

	// Prepare memory
	if (!Memory.exploits) {
		Memory.exploits = {};
	}

	if (!Memory.exploits[roomName]) {
		Memory.exploits[roomName] = {};
	}

	this.memory = Memory.exploits[roomName];

	// Adjust flag color.
	if (this.flag.color !== COLOR_RED) {
		this.flag.setColor(COLOR_RED);
	}

	this.collectCreeps();
	this.collectLairs();
	this.collectSources();

	// Cache paths around the room.
	this.calculatePaths();

	// Save closest lair to entrance point.
	if (this.memory.lairs && this.memory.pathToRoom && !this.memory.closestLairToEntrance) {
		const lastPos = utilities.decodePosition(this.memory.pathToRoom[this.memory.pathToRoom.length - 1]);
		let bestRange = null;
		let best = null;
		for (const lairData of this.memory.lairs) {
			const lair = Game.getObjectById(lairData.id);
			if (lair && (!best || lastPos.getRangeTo(lair) < bestRange)) {
				best = lairData.id;
				bestRange = lastPos.getRangeTo(lair);
			}
		}

		if (best) {
			this.memory.closestLairToEntrance = best;
		}
	}

	// Try and build roads where needed.
	this.buildRoads();
};

/**
 * Collects creeps from temp data.
 */
Exploit.prototype.collectCreeps = function () {
	if (Game.exploitTemp && Game.exploitTemp[this.name]) {
		for (const id of Game.exploitTemp[this.name]) {
			const creep = Game.getObjectById(id);

			if (!this.units[creep.memory.exploitUnitType]) {
				this.units[creep.memory.exploitUnitType] = [];
			}

			this.units[creep.memory.exploitUnitType].push(creep);
		}
	}
};

/**
 * Collects source keeper lair positions.
 */
Exploit.prototype.collectLairs = function () {
	if (!this.memory.lairs && Memory.rooms[this.roomName] && Memory.rooms[this.roomName].intel) {
		const intel = Memory.rooms[this.roomName].intel;
		const lairs = intel.structures[STRUCTURE_KEEPER_LAIR];
		if (lairs) {
			this.memory.lairs = [];
			for (const id of _.keys(lairs)) {
				this.memory.lairs.push({
					id,
					paths: {},
				});
			}
		}
	}
};

/**
 * Collects sources belonging to lairs.
 */
Exploit.prototype.collectSources = function () {
	if (!this.memory.lairs || this.memory.sourcesChecked) return;
	if (Game.time - this.memory.sourcesChecked < 6542) return;

	let found = false;
	for (const lairData of this.memory.lairs) {
		const lair = Game.getObjectById(lairData.id);
		if (!lair) break;

		// Check sources.
		let sources = lair.pos.findInRange(FIND_SOURCES, 7);
		if (sources.length === 0) {
			sources = lair.pos.findInRange(FIND_MINERALS, 7);
		}

		for (const source of sources) {
			lairData.source = source.id;
			lairData.sourceType = source.mineralType || RESOURCE_ENERGY;
			break;
		}

		found = true;
	}

	if (found) {
		this.memory.sourcesChecked = Game.time;
	}
};

/**
 * Builds roads in the exploited room.
 */
Exploit.prototype.buildRoads = function () {
	if (this.memory.lastRoadCheck && Game.time - this.memory.lastRoadCheck < 51) return;
	if (_.size(Game.constructionSites) > 75) return;
	if (!Game.rooms[this.roomName]) return;

	const room = Game.rooms[this.roomName];
	this.numConstructionSites = room.find(FIND_CONSTRUCTION_SITES).length;
	this.memory.lastRoadCheck = Game.time;

	this.buildRoadsForPath(this.memory.pathToRoom);

	if (!this.memory.lairs) return;
	const lairMemory = this.memory.lairs;

	for (const lairData of lairMemory) {
		this.buildRoadsForPath(lairData.sourcePath && lairData.sourcePath.path, true);

		for (const id2 of _.map(lairMemory, 'id')) {
			this.buildRoadsForPath(lairData.paths[id2] && lairData.paths[id2].path);
		}
	}
};

/**
 * Builds roads along a given path, optionally with container at the end.
 *
 * @param {string[]} path
 *   An array of encoded room positions.
 * @param {boolean} addContainer
 *   Whether to build a container near the end of the path.
 */
Exploit.prototype.buildRoadsForPath = function (path, addContainer) {
	if (!path) return;

	for (let i = 0; i < path.length; i++) {
		const pos = utilities.decodePosition(path[i]);
		if (pos.roomName !== this.roomName) continue;

		// Build containers close to sources.
		const buildContainer = addContainer && i === path.length - 2;
		if (!this.tryBuildRoad(pos, buildContainer)) return;
	}
};

/**
 * Tries to create a construction site for a road.
 *
 * This method checks if other structures or construction sites exist at this
 * position first, and created no more than 10 construction sites in the room.
 *
 * @param {RoomPosition} pos
 *   The position to create the construction site at.
 * @param {boolean} addContainer
 *   Whether to also build a container at this position.
 *
 * @return {boolean}
 *   True if further construction sites can be created.
 */
Exploit.prototype.tryBuildRoad = function (pos, addContainer) {
	const structures = _.groupBy(pos.lookFor(LOOK_STRUCTURES), 'structureType');
	const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

	if (sites.length > 0) return true;
	if (_.size(structures[STRUCTURE_ROAD]) === 0 && pos.createConstructionSite(STRUCTURE_ROAD) === OK) {
		this.numConstructionSites++;
	}

	if (addContainer && _.size(structures[STRUCTURE_CONTAINER]) === 0 && pos.createConstructionSite(STRUCTURE_CONTAINER) === OK) {
		this.numConstructionSites++;
	}

	return this.numConstructionSites < 10;
};

/**
 * Calculates paths needed in exploit room.
 */
Exploit.prototype.calculatePaths = function () {
	// Calculate path into room.
	if (!this.memory.pathToRoom || !this.memory.pathToRoomCalculated || this.memory.pathToRoomCalculated < Game.time - 10000) {
		const startLocation = this.sourceRoom.getStorageLocation();
		let startPosition = new RoomPosition(startLocation.x, startLocation.y, this.sourceRoom.name);
		if (this.sourceRoom.storage) {
			startPosition = this.sourceRoom.storage.pos;
		}

		const endPosition = new RoomPosition(25, 25, this.flag.pos.roomName);

		const result = utilities.getPath(startPosition, {pos: endPosition, range: 20});

		if (result) {
			this.memory.pathToRoom = utilities.serializePositionPath(result.path);
			this.memory.pathToRoomCalculated = Game.time;
			delete this.memory.closestLairToEntrance;
		}
		else {
			console.log('No path found!');
		}

		return;
	}

	const lairMemory = this.memory.lairs;
	for (const lairData of lairMemory) {
		// Calculate paths between source keeper lairs.
		for (const lairData2 of lairMemory) {
			if (lairData.id === lairData2.id) continue;
			if (lairData.paths[lairData2.id]) continue;

			const lair = Game.getObjectById(lairData.id);
			const lair2 = Game.getObjectById(lairData2.id);

			if (!lair || !lair2) continue;

			const result = utilities.getPath(lair.pos, {pos: lair2.pos, range: 1});

			if (result) {
				lairData.paths[lairData2.id] = {
					path: utilities.serializePositionPath(result.path),
					lastCalculated: Game.time,
				};
				lairData2.paths[lairData.id] = {
					reverse: true,
					lastCalculated: Game.time,
				};
			}
			else {
				console.log('No path found!');
			}

			return;
		}

		// Calculate paths between lairs and actual sources.
		if (lairData.source && !lairData.sourcePath) {
			const lair = Game.getObjectById(lairData.id);
			const source = Game.getObjectById(lairData.source);

			if (!lair || !source) continue;

			const result = utilities.getPath(lair.pos, {pos: source.pos, range: 1});

			if (result) {
				lairData.sourcePath = {
					path: utilities.serializePositionPath(result.path),
					lastCalculated: Game.time,
				};
			}
			else {
				console.log('No path found!');
			}

			return;
		}
	}
};

/**
 * Adds creeps for this exploit operation to spawn queue.
 *
 * @param {object} options
 *   Current spawn options that we will add to.
 */
Exploit.prototype.addSpawnOptions = function (options) {
	// Spawn a guardian that travels around the room to keep sources safe.
	let numGuardians = 0;
	if (this.units.guardian) {
		for (const creep of this.units.guardian) {
			// Only counts if it has longer to live than it takes us to respawn and get a new creep there.
			if (!creep.ticksToLive || creep.ticksToLive > (_.size(creep.body) * 3) + _.size(this.memory.pathToRoom) + 50) {
				numGuardians++;
			}
		}
	}

	if (numGuardians < 1) {
		// @todo Spawn in time to arrive when previous guardian expires.
		// @todo Only spawn guardian if room is protected by source keepers.
		options.push({
			role: 'exploit',
			priority: 3,
			weight: 1,
			subRole: 'guardian',
			exploit: this.name,
		});
	}

	// When necessary, spawn a builder to create a road network and containers.
	const numSites = _.size(_.filter(Game.constructionSites, site => site.pos.roomName === this.roomName));
	let maxBuilders = Math.ceil(numSites / 7);

	// Send a builder if containers are decaying too much.
	if (maxBuilders === 0 && this.memory.lairs) {
		for (const lairData of this.memory.lairs) {
			const source = Game.getObjectById(lairData.source);
			if (source) {
				const container = source.getNearbyContainer();
				if (container && container.hits < container.hitsMax * 0.5) {
					maxBuilders = 1;
					break;
				}
			}
		}
	}

	if (numSites > 0 && _.size(_.filter(this.units.builder, creep => creep.ticksToLive && creep.ticksToLive > (_.size(creep.body) * 3) + _.size(this.memory.pathToRoom) + 50)) < maxBuilders) {
		// @todo Maybe even spawn 2 builders when roads are still being built, but only use 1 when doing repairs.
		options.push({
			role: 'exploit',
			priority: 3,
			weight: 0.5,
			subRole: 'builder',
			exploit: this.name,
		});
	}

	this.addHarvesterSpawnOptions(options);
};

/**
 * Decides when and how many harvesters and haulers should be spawned.
 *
 * @param {object} options
 *   Current spawn options that we will add to.
 */
Exploit.prototype.addHarvesterSpawnOptions = function (options) {
	// Once containers are build, send harvesters.
	if (!this.memory.lairs) return;

	let activeLairs = 0;
	let activeLairPathLength = 0;
	const roomPathLength = _.size(this.memory.pathToRoom);

	for (const lairData of this.memory.lairs) {
		const source = Game.getObjectById(lairData.source);
		if (!source || !source.getNearbyContainer()) continue;

		// Regenerating mineral sources are also considered inactive.
		if (source.mineralType && source.mineralAmount <= 0) continue;

		activeLairs++;
		activeLairPathLength += roomPathLength;
		if (lairData.id !== this.memory.closestLairToEntrance) {
			const id2 = this.memory.closestLairToEntrance;
			if (lairData.paths[id2]) {
				activeLairPathLength += _.size(lairData.paths[id2].path);
				activeLairPathLength += _.size(this.memory.lairs[id2].paths[lairData.id].path);
			}
		}

		let numHarvesters = 0;
		if (this.units.harvester) {
			numHarvesters += _.filter(this.units.harvester, creep => creep.memory.fixedSource === source.id && (!creep.ticksToLive || creep.ticksToLive > (_.size(creep.body) * 3) + _.size(this.memory.pathToRoom) + 20)).length;
		}

		if (numHarvesters < 1) {
			options.push({
				role: 'exploit',
				priority: 3,
				weight: 0.1,
				subRole: 'harvester',
				exploit: this.name,
				source: source.id,
				resourceType: source.mineralType || RESOURCE_ENERGY,
			});
		}
	}

	const production = activeLairs * 4500 / 300;
	const productionAfterRoundTrip = 2 * activeLairPathLength * production;
	const neededWorkParts = productionAfterRoundTrip / 50;

	let totalWorkParts = 0;
	if (this.units.hauler) {
		for (const creep of this.units.hauler) {
			totalWorkParts += creep.memory.body.carry || 0;
		}
	}

	if (totalWorkParts < neededWorkParts * 0.5) { // Conservative for now.
		options.push({
			role: 'exploit',
			priority: 3,
			weight: 0,
			subRole: 'hauler',
			exploit: this.name,
		});
	}
};

/**
 * Spawns one of our exploit units.
 *
 * @param {StructureSpawn} spawn
 *   The spawn to create the creep at.
 * @param {object} option
 *   Options about the creep to spawn.
 */
Exploit.prototype.spawnUnit = function (spawn, option) {
	if (option.subRole === 'guardian') {
		const body = new Array(50);
		_.fill(body, MOVE, 0, 25);
		_.fill(body, ATTACK, 25, 44);
		body[44] = MOVE;
		_.fill(body, HEAL, 45, 50);

		spawn.createManagedCreep({
			role: 'brawler',
			body,
			memory: {
				exploitName: this.name,
				exploitUnitType: 'guardian',
			},
		});
	}
	else if (option.subRole === 'builder') {
		spawn.createManagedCreep({
			role: 'builder.exploit',
			bodyWeights: {move: 0.4, carry: 0.3, work: 0.3},
			memory: {
				exploitName: this.name,
				exploitUnitType: 'builder',
			},
		});
	}
	else if (option.subRole === 'harvester') {
		const config = {
			role: 'harvester.exploit',
			bodyWeights: {move: 0.35, carry: 0.15, work: 0.5},
			memory: {
				exploitName: this.name,
				exploitUnitType: 'harvester',
				fixedSource: option.source,
			},
		};

		if (option.resourceType === RESOURCE_ENERGY) {
			config.maxParts = {work: 9};
		}

		spawn.createManagedCreep(config);
	}
	else if (option.subRole === 'hauler') {
		spawn.createManagedCreep({
			role: 'hauler.exploit',
			bodyWeights: {move: 0.35, carry: 0.65},
			memory: {
				exploitName: this.name,
				exploitUnitType: 'hauler',
			},
		});
	}
};

module.exports = Exploit;
