'use strict';

/* global Creep RoomPosition FIND_DROPPED_RESOURCES RESOURCE_ENERGY
FIND_CONSTRUCTION_SITES STRUCTURE_CONTAINER */

/**
 * Makes the creep gather resources in the current room.
 */
Creep.prototype.performExploitHarvest = function () {
	const creep = this;
	const source = Game.getObjectById(creep.memory.fixedSource);
	const container = source.getNearbyContainer();

	if (source.isDangerous()) {
		const safeSpot = new RoomPosition(25, 25, this.room.name);
		if (this.pos.getRangeTo(safeSpot) > 5) {
			this.moveToRange(safeSpot, 5);
		}

		return;
	}

	if (!container || _.sum(container.store) < container.storeCapacity) {
		// Pick up nearby resources and put in container.
		const dropped = this.pos.findInRange(FIND_DROPPED_RESOURCES, 5, {
			filter: resources => container || resources.resourceType === RESOURCE_ENERGY,
		});
		if (dropped.length > 0) {
			if (creep.pos.getRangeTo(dropped[0]) > 1) {
				creep.moveToRange(dropped[0], 1);
			}
			else {
				creep.pickup(dropped[0]);
			}

			return true;
		}
	}

	if (creep.pos.getRangeTo(source) > 1) {
		creep.moveTo(source);
	}
	else {
		creep.harvest(source);
	}

	// If there's a container nearby, directly deposit energy.
	if (_.sum(creep.carry) > creep.carryCapacity * 0.5) {
		if (container && creep.pos.getRangeTo(container) <= 1) {
			for (const resourceType in this.carry) {
				if (this.carry[resourceType] <= 0) continue;
				creep.transfer(container, resourceType);
				break;
			}
		}
	}

	return true;
};

/**
 * Dumps minerals a harvester creep has gathered.
 */
Creep.prototype.performExploitHarvesterDeliver = function () {
	const source = Game.getObjectById(this.memory.fixedSource);
	const container = source.getNearbyContainer();

	// By default, deliver to nearby container if there's space.
	// @todo Deliver anything, not just what the source provides.
	if (container && _.sum(container.store) < container.storeCapacity) {
		if (this.pos.getRangeTo(container) > 1) {
			this.moveTo(container);
		}
		else {
			for (const resourceType in this.carry) {
				if (this.carry[resourceType] <= 0) continue;
				this.transfer(container, resourceType);
				break;
			}
		}
	}
	else {
		// Just drop it. Somebody will pick it up. Maybe.
		this.drop(source.mineralType || RESOURCE_ENERGY);
	}

	return true;
};

/**
 * Puts this creep into or out of harvesting mode.
 */
Creep.prototype.setHarvesterState = function (harvesting) {
	this.memory.harvesting = harvesting;
	delete this.memory.resourceTarget;
};

/**
 * Makes a creep behave like an exploit harvester.
 */
Creep.prototype.runExploitHarvesterLogic = function () {
	if (!this.memory.harvesting && _.sum(this.carry) <= 0) {
		this.setHarvesterState(true);
	}
	else if (this.memory.harvesting && _.sum(this.carry) >= this.carryCapacity) {
		this.setHarvesterState(false);
	}

	const exploit = Game.exploits[this.memory.exploitName];
	if (exploit) {
		// Follow cached path when requested.
		if (this.hasCachedPath()) {
			this.followCachedPath();
			if (this.hasArrived()) {
				this.clearCachedPath();
				if (this.memory.travellingToRoom) {
					// Next, travel to destined source.
					const closest = exploit.memory.closestLairToEntrance;
					const source = Game.getObjectById(this.memory.fixedSource);
					if (closest && source && exploit.memory.lairs[closest]) {
						const lair = source.getNearbyLair();
						if (lair) {
							const target = lair.id;
							const path = exploit.memory.lairs[closest].paths[target];
							if (path) {
								if (path.path) {
									this.setCachedPath(exploit.memory.lairs[closest].paths[target].path, false, 3);
								}
								else {
									this.setCachedPath(exploit.memory.lairs[target].paths[closest].path, true, 3);
								}
							}
						}
					}

					delete this.memory.travellingToRoom;
				}
			}
			else {
				return true;
			}
		}
		else if (this.pos.roomName !== exploit.roomName && exploit.memory.pathToRoom) {
			this.setCachedPath(exploit.memory.pathToRoom, false, 3);
			this.memory.travellingToRoom = true;
			return true;
		}
	}

	// Make sure to keep nearby container repaired.
	const source = Game.getObjectById(this.memory.fixedSource);
	const container = source.getNearbyContainer();

	if (this.carry.energy > 0) {
		if (!container) {
			// If a construction site for a container is nearby, help build it to recover.
			const sites = this.pos.findInRange(FIND_CONSTRUCTION_SITES, 3, {
				filter: site => site.structureType === STRUCTURE_CONTAINER,
			});
			if (sites.length > 0 && this.carry.energy >= (this.memory.body.work || 0) * 5) {
				this.build(sites[0]);
				return;
			}
		}
		else if (container.hits < container.hitsMax * 0.2 && !source.isDangerous() && this.carry.energy >= (this.memory.body.work || 0)) {
			if (this.pos.getRangeTo(container) > 3) {
				this.moveTo(container);
			}
			else {
				this.repair(container);
			}

			return;
		}
	}

	if (this.memory.harvesting) {
		return this.performExploitHarvest();
	}

	return this.performExploitHarvesterDeliver();
};
